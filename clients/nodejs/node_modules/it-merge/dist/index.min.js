(function (root, factory) {(typeof module === 'object' && module.exports) ? module.exports = factory() : root.ItMerge = factory()}(typeof self !== 'undefined' ? self : this, function () {
"use strict";var ItMerge=(()=>{var o=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var x=Object.prototype.hasOwnProperty;var m=(t,e)=>{for(var r in e)o(t,r,{get:e[r],enumerable:!0})},w=(t,e,r,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of f(e))!x.call(t,s)&&s!==r&&o(t,s,{get:()=>e[s],enumerable:!(n=d(e,s))||n.enumerable});return t};var y=t=>w(o({},"__esModule",{value:!0}),t);var g={};m(g,{default:()=>S});function a(){let t={};return t.promise=new Promise((e,r)=>{t.resolve=e,t.reject=r}),t}var i=class extends Error{type;code;constructor(e,r,n){super(e??"The operation was aborted"),this.type="aborted",this.name=n??"AbortError",this.code=r??"ABORT_ERR"}};async function l(t,e,r){if(e==null)return t;if(e.aborted)return t.catch(()=>{}),Promise.reject(new i(r?.errorMessage,r?.errorCode,r?.errorName));let n,s=new i(r?.errorMessage,r?.errorCode,r?.errorName);try{return await Promise.race([t,new Promise((P,c)=>{n=()=>{c(s)},e.addEventListener("abort",n)})])}finally{n!=null&&e.removeEventListener("abort",n)}}var u=class{readNext;haveNext;ended;nextResult;error;constructor(){this.ended=!1,this.readNext=a(),this.haveNext=a()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");let e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=a(),e}async throw(e){return this.ended=!0,this.error=e,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){let e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,r){await this._push(e,r)}async end(e,r){e!=null?await this.throw(e):await this._push(void 0,r)}async _push(e,r){if(e!=null&&this.ended)throw this.error??new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=a(),await l(this.readNext.promise,r?.signal,r)}};function h(){return new u}function v(t){return t[Symbol.asyncIterator]!=null}async function p(t,e){try{await Promise.all(t.map(async r=>{for await(let n of r)await e.push(n)})),await e.end()}catch(r){await e.end(r).catch(()=>{})}}async function*N(t){let e=h();p(t,e).catch(()=>{}),yield*e}function*R(t){for(let e of t)yield*e}function b(...t){let e=[];for(let r of t)v(r)||e.push(r);return e.length===t.length?R(e):N(t)}var S=b;return y(g);})();
return ItMerge}));
